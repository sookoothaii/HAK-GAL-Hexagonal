# Smart Calculator with History
# Generated by Gemini
# Fokus: Code-Qualität und Effizienz

import math

# Globale Liste zur Speicherung der Historie als Tupel (Operation, Ergebnis)
# Dies ist effizienter für spätere Berechnungen (Avg, Min, Max)
history = []

def get_numbers(num_count=2):
    """Holt eine oder zwei Zahlen vom Benutzer und führt eine robuste Fehlerbehandlung durch."""
    try:
        if num_count == 1:
            a = float(input("Geben Sie die Zahl ein: "))
            return (a,)
        else:
            a = float(input("Geben Sie die erste Zahl ein: "))
            b = float(input("Geben Sie die zweite Zahl ein: "))
            return a, b
    except ValueError:
        print("\nFEHLER: Ungültige Eingabe. Bitte geben Sie nur Zahlen ein.")
        return None

def show_history():
    """Zeigt die letzten 5 Berechnungen an."""
    if not history:
        print("\nDie Historie ist leer.")
    else:
        print("\n--- Letzte 5 Berechnungen ---")
        # Effizientes Slicing, um nur die letzten 5 Elemente zu durchlaufen
        for entry_str, _ in history[-5:]:
            print(entry_str)
        print("--------------------------")

def clear_history():
    """Löscht die gesamte Historie."""
    history.clear()
    print("\nHistorie wurde gelöscht.")

def show_advanced_stats():
    """Berechnet und zeigt Durchschnitt, Minimum und Maximum der Historie."""
    # Extrahiert nur numerische Ergebnisse, ignoriert Fehler-Strings
    results = [res for _, res in history if isinstance(res, (int, float))]
    
    if not results:
        print("\nKeine validen Ergebnisse in der Historie für Statistiken.")
        return

    # Effiziente Berechnung in einem Durchlauf
    total = sum(results)
    average = total / len(results)
    minimum = min(results)
    maximum = max(results)

    print("\n--- Erweiterte Statistiken ---")
    print(f"Durchschnitt aller Ergebnisse: {average:.2f}")
    print(f"Minimales Ergebnis: {minimum}")
    print(f"Maximales Ergebnis: {maximum}")
    print("----------------------------")

def export_history_to_file():
    """Exportiert die Historie effizient in eine Textdatei."""
    if not history:
        print("\nHistorie ist leer. Nichts zu exportieren.")
        return
    
    filename = "calculator_history.txt"
    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write("--- Rechnerhistorie ---\n")
            # Verwende einen Generator-Ausdruck für speichereffizientes Schreiben
            f.writelines(f"{entry_str}\n" for entry_str, _ in history)
        print(f"\nHistorie wurde erfolgreich in '{filename}' exportiert.")
    except IOError as e:
        print(f"\nFEHLER beim Exportieren der Historie: {e}")

def print_menu():
    """Druckt das Hauptmenü."""
    print("""
--- Smart Calculator Menü ---
1. Addieren (+)              6. Wurzelziehen (sqrt)
2. Subtrahieren (-)          7. Letzte 5 Berechnungen anzeigen
3. Multiplizieren (*)        8. Erweiterte Statistiken (Avg, Min, Max)
4. Dividieren (/)            9. Historie löschen
5. Potenzieren (a^b)         10. Historie in Datei exportieren
---------------------------
0. Beenden
---------------------------"")

def main():
    """Hauptfunktion und Schleife des Programms."""
    # Dictionary für Operationen, um if/elif-Ketten zu vermeiden (effizienter und sauberer)
    operations = {
        '1': (lambda a, b: a + b, "+", 2),
        '2': (lambda a, b: a - b, "-", 2),
        '3': (lambda a, b: a * b, "*", 2),
        '4': (lambda a, b: a / b if b != 0 else "Fehler: Division durch Null", "/", 2),
        '5': (lambda a, b: a ** b, "^", 2),
        '6': (lambda a: math.sqrt(a) if a >= 0 else "Fehler: Wurzel aus negativer Zahl", "sqrt", 1)
    }

    while True:
        print_menu()
        choice = input("Bitte wählen Sie eine Option: ")

        if choice == '0':
            print("Programm wird beendet.")
            break
        
        # UI-Optionen direkt behandeln
        if choice == '7':
            show_history()
            continue
        if choice == '8':
            show_advanced_stats()
            continue
        if choice == '9':
            clear_history()
            continue
        if choice == '10':
            export_history_to_file()
            continue

        # Berechnungen durchführen
        if choice in operations:
            op_func, op_symbol, num_args = operations[choice]
            
            user_input = get_numbers(num_args)
            if user_input is None:
                continue

            result = op_func(*user_input)
            
            # Formatierungs-String für die Historie erstellen
            if num_args == 1:
                op_str = f"{op_symbol}({user_input[0]})"
            else:
                op_str = f"{user_input[0]} {op_symbol} {user_input[1]}"
            
            full_entry_str = f"{op_str} = {result}"
            print(f"\nErgebnis: {result}")
            history.append((full_entry_str, result))

        else:
            print("\nFEHLER: Ungültige Auswahl. Bitte versuchen Sie es erneut.")

if __name__ == "__main__":
    main()
